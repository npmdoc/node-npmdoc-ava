<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://ava.li"

    >ava (v0.19.1)</a>
</h1>
<h4>Futuristic test runner ðŸš€</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.ava">module ava</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ava.ava_files">
            function <span class="apidocSignatureSpan">ava.</span>ava_files
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ava.</span>_iron_node</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ava.</span>assert</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ava.</span>babel_config</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ava.</span>colors</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ava.</span>format_assert_error</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ava.</span>globals</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ava.</span>improper_usage_messages</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ava._iron_node">module ava._iron_node</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ava._iron_node.workSpaceDirectory">
            function <span class="apidocSignatureSpan">ava._iron_node.</span>workSpaceDirectory
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ava._iron_node.</span>app</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ava.assert">module ava.assert</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ava.assert.AssertionError">
            function <span class="apidocSignatureSpan">ava.assert.</span>AssertionError
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ava.assert.wrapAssertions">
            function <span class="apidocSignatureSpan">ava.assert.</span>wrapAssertions
            <span class="apidocSignatureSpan">(callbacks)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ava.ava_files">module ava.ava_files</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ava.ava_files.ava_files">
            function <span class="apidocSignatureSpan">ava.</span>ava_files
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ava.ava_files.defaultExcludePatterns">
            function <span class="apidocSignatureSpan">ava.ava_files.</span>defaultExcludePatterns
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ava.ava_files.defaultIncludePatterns">
            function <span class="apidocSignatureSpan">ava.ava_files.</span>defaultIncludePatterns
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ava.babel_config">module ava.babel_config</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ava.babel_config.build">
            function <span class="apidocSignatureSpan">ava.babel_config.</span>build
            <span class="apidocSignatureSpan">(projectDir, cacheDir, userOptions, powerAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ava.babel_config.validate">
            function <span class="apidocSignatureSpan">ava.babel_config.</span>validate
            <span class="apidocSignatureSpan">(conf)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ava.colors">module ava.colors</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ava.colors.duration">
            function <span class="apidocSignatureSpan">ava.colors.</span>duration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ava.colors.error">
            function <span class="apidocSignatureSpan">ava.colors.</span>error
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ava.colors.errorSource">
            function <span class="apidocSignatureSpan">ava.colors.</span>errorSource
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ava.colors.errorStack">
            function <span class="apidocSignatureSpan">ava.colors.</span>errorStack
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ava.colors.information">
            function <span class="apidocSignatureSpan">ava.colors.</span>information
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ava.colors.pass">
            function <span class="apidocSignatureSpan">ava.colors.</span>pass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ava.colors.skip">
            function <span class="apidocSignatureSpan">ava.colors.</span>skip
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ava.colors.stack">
            function <span class="apidocSignatureSpan">ava.colors.</span>stack
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ava.colors.title">
            function <span class="apidocSignatureSpan">ava.colors.</span>title
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ava.colors.todo">
            function <span class="apidocSignatureSpan">ava.colors.</span>todo
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ava.format_assert_error">module ava.format_assert_error</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ava.format_assert_error.formatDiff">
            function <span class="apidocSignatureSpan">ava.format_assert_error.</span>formatDiff
            <span class="apidocSignatureSpan">(actual, expected)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ava.format_assert_error.formatSerializedError">
            function <span class="apidocSignatureSpan">ava.format_assert_error.</span>formatSerializedError
            <span class="apidocSignatureSpan">(error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ava.format_assert_error.formatValue">
            function <span class="apidocSignatureSpan">ava.format_assert_error.</span>formatValue
            <span class="apidocSignatureSpan">(value, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ava.format_assert_error.formatWithLabel">
            function <span class="apidocSignatureSpan">ava.format_assert_error.</span>formatWithLabel
            <span class="apidocSignatureSpan">(label, value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ava.globals">module ava.globals</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ava.globals.clearTimeout">
            function <span class="apidocSignatureSpan">ava.globals.</span>clearTimeout
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ava.globals.now">
            function <span class="apidocSignatureSpan">ava.globals.</span>now
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ava.globals.setImmediate">
            function <span class="apidocSignatureSpan">ava.globals.</span>setImmediate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ava.globals.setTimeout">
            function <span class="apidocSignatureSpan">ava.globals.</span>setTimeout
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ava.globals.</span>options</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ava.improper_usage_messages">module ava.improper_usage_messages</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ava.improper_usage_messages.forError">
            function <span class="apidocSignatureSpan">ava.improper_usage_messages.</span>forError
            <span class="apidocSignatureSpan">(!error.improperUsage)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ava" id="apidoc.module.ava">module ava</a></h1>


    <h2>
        <a href="#apidoc.element.ava.ava_files" id="apidoc.element.ava.ava_files">
        function <span class="apidocSignatureSpan">ava.</span>ava_files
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class AvaFiles {
	constructor(options) {
		options = options || {};

		let files = (options.files || []).map(file =&#x3e; {
			// `./` should be removed from the beginning of patterns because
			// otherwise they won&#x27;t match change events from Chokidar
			if (file.slice(0, 2) === &#x27;./&#x27;) {
				return file.slice(2);
			}

			return file;
		});

		if (files.length === 0) {
			files = defaultIncludePatterns();
		}

		this.excludePatterns = defaultExcludePatterns();
		this.files = files;
		this.sources = options.sources || [];
		this.cwd = options.cwd || process.cwd();

		autoBind(this);
	}
	findTestFiles() {
		return handlePaths(this.files, this.excludePatterns, {
			cwd: this.cwd,
			cache: Object.create(null),
			statCache: Object.create(null),
			realpathCache: Object.create(null),
			symlinks: Object.create(null)
		});
	}
	findTestHelpers() {
		return handlePaths(defaultHelperPatterns(), [&#x27;!**/node_modules/**&#x27;], {
			cwd: this.cwd,
			includeUnderscoredFiles: true,
			cache: Object.create(null),
			statCache: Object.create(null),
			realpathCache: Object.create(null),
			symlinks: Object.create(null)
		});
	}
	isSource(filePath) {
		let mixedPatterns = [];
		const defaultIgnorePatterns = getDefaultIgnorePatterns();
		const overrideDefaultIgnorePatterns = [];

		let hasPositivePattern = false;
		this.sources.forEach(pattern =&#x3e; {
			mixedPatterns.push(pattern);

			// TODO: Why not just `pattern[0] !== &#x27;!&#x27;`?
			if (!hasPositivePattern &#x26;&#x26; pattern[0] !== &#x27;!&#x27;) {
				hasPositivePattern = true;
			}

			// Extract patterns that start with an ignored directory. These need to be
			// rematched separately.
			if (defaultIgnore.indexOf(pattern.split(&#x27;/&#x27;)[0]) &#x3e;= 0) {
				overrideDefaultIgnorePatterns.push(pattern);
			}
		});

		// Same defaults as used for Chokidar
		if (!hasPositivePattern) {
			mixedPatterns = [&#x27;package.json&#x27;, &#x27;**/*.js&#x27;].concat(mixedPatterns);
		}

		filePath = matchable(filePath);

		// Ignore paths outside the current working directory.
		// They can&#x27;t be matched to a pattern.
		if (/^\.\.\//.test(filePath)) {
			return false;
		}

		const isSource = multimatch(filePath, mixedPatterns).length === 1;
		if (!isSource) {
			return false;
		}

		const isIgnored = multimatch(filePath, defaultIgnorePatterns).length === 1;
		if (!isIgnored) {
			return true;
		}

		const isErroneouslyIgnored = multimatch(filePath, overrideDefaultIgnorePatterns).length === 1;
		if (isErroneouslyIgnored) {
			return true;
		}

		return false;
	}
	isTest(filePath) {
		const excludePatterns = this.excludePatterns;
		const initialPatterns = this.files.concat(excludePatterns);

		// Like in `api.js`, tests must be `.js` files and not start with `_`
		if (path.extname(filePath) !== &#x27;.js&#x27; || path.basename(filePath)[0] === &#x27;_&#x27;) {
			return false;
		}

		// Check if the entire path matches a pattern
		if (multimatch(matchable(filePath), initialPatterns).length === 1) {
			return true;
		}

		// Check if the path contains any directory components
		const dirname = path.dirname(filePath);
		if (dirname === &#x27;.&#x27;) {
			return false;
		}

		// Compute all possible subpaths. Note that the dirname is assumed to be
		// relative to the working directory, without a leading `./`.
		const subpaths = dirname.split(/[\\/]/).reduce((subpaths, component) =&#x3e; {
			const parent = subpaths[subpaths.length - 1];

			if (parent) {
				// Always use `/`` to makes multimatch consistent across platforms
				subpaths.push(`${parent}/${component}`);
			} else {
				subpaths.push(component);
			}

			return subpaths;
		}, []);

		// Check if any of the possible subpaths match a pattern. If so, generate a
		// new pattern with **/*.js.
		const recursivePatterns = subpaths
			.filter(subpath =&#x3e; multimatch(subpath, initialPatterns).length === 1)
			// Always use `/` to makes multimatch consistent across platforms
			.map(subpath =&#x3e; `${subpath}/**/*.js`);

		// See if the entire path matches any of the subpaths patterns, taking the
		// excludePatterns into account. This mimicks the behavior in api.js
		return multimatch(matchable(filePath), recursivePatterns.concat(excludePattern ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ava._iron_node" id="apidoc.module.ava._iron_node">module ava._iron_node</a></h1>


    <h2>
        <a href="#apidoc.element.ava._iron_node.workSpaceDirectory" id="apidoc.element.ava._iron_node.workSpaceDirectory">
        function <span class="apidocSignatureSpan">ava._iron_node.</span>workSpaceDirectory
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">() =&#x3e; __dirname</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ava.assert" id="apidoc.module.ava.assert">module ava.assert</a></h1>


    <h2>
        <a href="#apidoc.element.ava.assert.AssertionError" id="apidoc.element.ava.assert.AssertionError">
        function <span class="apidocSignatureSpan">ava.assert.</span>AssertionError
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class AssertionError extends Error {
	constructor(opts) {
		super(opts.message || &#x27;&#x27;);
		this.name = &#x27;AssertionError&#x27;;

		this.assertion = opts.assertion;
		this.fixedSource = opts.fixedSource;
		this.improperUsage = opts.improperUsage || false;
		this.operator = opts.operator;
		this.values = opts.values || [];

		// Reserved for power-assert statements
		this.statements = [];

		if (opts.stack) {
			this.stack = opts.stack;
		}
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ava.assert.wrapAssertions" id="apidoc.element.ava.assert.wrapAssertions">
        function <span class="apidocSignatureSpan">ava.assert.</span>wrapAssertions
        <span class="apidocSignatureSpan">(callbacks)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrapAssertions(callbacks) {
	const pass = callbacks.pass;
	const pending = callbacks.pending;
	const fail = callbacks.fail;

	const noop = () =&#x3e; {};
	const makeNoop = () =&#x3e; noop;
	const makeRethrow = reason =&#x3e; () =&#x3e; {
		throw reason;
	};

	const assertions = {
		pass() {
			pass(this);
		},

		fail(message) {
			fail(this, new AssertionError({
				assertion: &#x27;fail&#x27;,
				message: message || &#x27;Test failed via `t.fail()`&#x27;
			}));
		},

		is(actual, expected, message) {
			if (actual === expected) {
				pass(this);
			} else {
				const diff = formatAssertError.formatDiff(actual, expected);
				const values = diff ? [diff] : [
					formatAssertError.formatWithLabel(&#x27;Actual:&#x27;, actual),
					formatAssertError.formatWithLabel(&#x27;Must be strictly equal to:&#x27;, expected)
				];

				fail(this, new AssertionError({
					assertion: &#x27;is&#x27;,
					message,
					operator: &#x27;===&#x27;,
					values
				}));
			}
		},

		not(actual, expected, message) {
			if (actual === expected) {
				fail(this, new AssertionError({
					assertion: &#x27;not&#x27;,
					message,
					operator: &#x27;!==&#x27;,
					values: [formatAssertError.formatWithLabel(&#x27;Value is strictly equal:&#x27;, actual)]
				}));
			} else {
				pass(this);
			}
		},

		deepEqual(actual, expected, message) {
			if (deepEqual(actual, expected)) {
				pass(this);
			} else {
				const diff = formatAssertError.formatDiff(actual, expected);
				const values = diff ? [diff] : [
					formatAssertError.formatWithLabel(&#x27;Actual:&#x27;, actual),
					formatAssertError.formatWithLabel(&#x27;Must be deeply equal to:&#x27;, expected)
				];

				fail(this, new AssertionError({
					assertion: &#x27;deepEqual&#x27;,
					message,
					values
				}));
			}
		},

		notDeepEqual(actual, expected, message) {
			if (deepEqual(actual, expected)) {
				fail(this, new AssertionError({
					assertion: &#x27;notDeepEqual&#x27;,
					message,
					values: [formatAssertError.formatWithLabel(&#x27;Value is deeply equal:&#x27;, actual)]
				}));
			} else {
				pass(this);
			}
		},

		throws(fn, err, message) {
			let promise;
			if (isPromise(fn)) {
				promise = fn;
			} else if (isObservable(fn)) {
				promise = observableToPromise(fn);
			} else if (typeof fn !== &#x27;function&#x27;) {
				fail(this, new AssertionError({
					assertion: &#x27;throws&#x27;,
					improperUsage: true,
					message: &#x27;`t.throws()` must be called with a function, Promise, or Observable&#x27;,
					values: [formatAssertError.formatWithLabel(&#x27;Called with:&#x27;, fn)]
				}));
				return;
			}

			let coreAssertThrowsErrorArg;
			if (typeof err === &#x27;string&#x27;) {
				const expectedMessage = err;
				coreAssertThrowsErrorArg = error =&#x3e; error.message === expectedMessage;
			} else {
				// Assume it&#x27;s a constructor function or regular expression
				coreAssertThrowsErrorArg = err;
			}

			const test = (fn, stack) =&#x3e; {
				let actual;
				let threw = false;
				try {
					coreAssert.throws(() =&#x3e; {
						try {
							fn();
						} catch (err) {
							actual = err;
							threw = true;
							throw err;
						}
					}, coreAssertThrowsErrorArg);
					return actual;
				} catch (err) {
					const values = threw ?
						[formatAssertError.formatWithLabel(&#x27;Threw unexpected exception:&#x27;, actual)] :
						null;

					throw new AssertionError({
						assertion: &#x27;throws&#x27;,
						message,
						stack,
						values
					});
				}
			};

			if (promise) {
				// Record stack before it gets lost in the promise chain.
				const stack = getStack();
				const intermediate = promise.then(makeNoop, makeRethrow).then(fn =&#x3e; test(fn, stack));
				pending(this, intermediate);
				// Don&#x27;t reject the returned promise, even if the assertion fails.
				return intermediate.catch(noop);
			}

			try {
				const retval = test(fn);
				pass(this);
				return retval;
			} catch (err) {
				fail(this, err);
			}
		},

		notThrows(fn, message) {
			let promise;
			if (isPromise(fn)) {
				promise = fn;
			} else if (isObservable(fn)) {
				promise = observableToPromise(fn);
			} else if (typeof fn !== &#x27;function&#x27;) {
				fail(this, new AssertionError({
					assertion: &#x27;notThrows&#x27;,
					improperUsage: true,
					message: &#x27;`t.notThrows()` must be called with a funct ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ava.ava_files" id="apidoc.module.ava.ava_files">module ava.ava_files</a></h1>


    <h2>
        <a href="#apidoc.element.ava.ava_files.ava_files" id="apidoc.element.ava.ava_files.ava_files">
        function <span class="apidocSignatureSpan">ava.</span>ava_files
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class AvaFiles {
	constructor(options) {
		options = options || {};

		let files = (options.files || []).map(file =&#x3e; {
			// `./` should be removed from the beginning of patterns because
			// otherwise they won&#x27;t match change events from Chokidar
			if (file.slice(0, 2) === &#x27;./&#x27;) {
				return file.slice(2);
			}

			return file;
		});

		if (files.length === 0) {
			files = defaultIncludePatterns();
		}

		this.excludePatterns = defaultExcludePatterns();
		this.files = files;
		this.sources = options.sources || [];
		this.cwd = options.cwd || process.cwd();

		autoBind(this);
	}
	findTestFiles() {
		return handlePaths(this.files, this.excludePatterns, {
			cwd: this.cwd,
			cache: Object.create(null),
			statCache: Object.create(null),
			realpathCache: Object.create(null),
			symlinks: Object.create(null)
		});
	}
	findTestHelpers() {
		return handlePaths(defaultHelperPatterns(), [&#x27;!**/node_modules/**&#x27;], {
			cwd: this.cwd,
			includeUnderscoredFiles: true,
			cache: Object.create(null),
			statCache: Object.create(null),
			realpathCache: Object.create(null),
			symlinks: Object.create(null)
		});
	}
	isSource(filePath) {
		let mixedPatterns = [];
		const defaultIgnorePatterns = getDefaultIgnorePatterns();
		const overrideDefaultIgnorePatterns = [];

		let hasPositivePattern = false;
		this.sources.forEach(pattern =&#x3e; {
			mixedPatterns.push(pattern);

			// TODO: Why not just `pattern[0] !== &#x27;!&#x27;`?
			if (!hasPositivePattern &#x26;&#x26; pattern[0] !== &#x27;!&#x27;) {
				hasPositivePattern = true;
			}

			// Extract patterns that start with an ignored directory. These need to be
			// rematched separately.
			if (defaultIgnore.indexOf(pattern.split(&#x27;/&#x27;)[0]) &#x3e;= 0) {
				overrideDefaultIgnorePatterns.push(pattern);
			}
		});

		// Same defaults as used for Chokidar
		if (!hasPositivePattern) {
			mixedPatterns = [&#x27;package.json&#x27;, &#x27;**/*.js&#x27;].concat(mixedPatterns);
		}

		filePath = matchable(filePath);

		// Ignore paths outside the current working directory.
		// They can&#x27;t be matched to a pattern.
		if (/^\.\.\//.test(filePath)) {
			return false;
		}

		const isSource = multimatch(filePath, mixedPatterns).length === 1;
		if (!isSource) {
			return false;
		}

		const isIgnored = multimatch(filePath, defaultIgnorePatterns).length === 1;
		if (!isIgnored) {
			return true;
		}

		const isErroneouslyIgnored = multimatch(filePath, overrideDefaultIgnorePatterns).length === 1;
		if (isErroneouslyIgnored) {
			return true;
		}

		return false;
	}
	isTest(filePath) {
		const excludePatterns = this.excludePatterns;
		const initialPatterns = this.files.concat(excludePatterns);

		// Like in `api.js`, tests must be `.js` files and not start with `_`
		if (path.extname(filePath) !== &#x27;.js&#x27; || path.basename(filePath)[0] === &#x27;_&#x27;) {
			return false;
		}

		// Check if the entire path matches a pattern
		if (multimatch(matchable(filePath), initialPatterns).length === 1) {
			return true;
		}

		// Check if the path contains any directory components
		const dirname = path.dirname(filePath);
		if (dirname === &#x27;.&#x27;) {
			return false;
		}

		// Compute all possible subpaths. Note that the dirname is assumed to be
		// relative to the working directory, without a leading `./`.
		const subpaths = dirname.split(/[\\/]/).reduce((subpaths, component) =&#x3e; {
			const parent = subpaths[subpaths.length - 1];

			if (parent) {
				// Always use `/`` to makes multimatch consistent across platforms
				subpaths.push(`${parent}/${component}`);
			} else {
				subpaths.push(component);
			}

			return subpaths;
		}, []);

		// Check if any of the possible subpaths match a pattern. If so, generate a
		// new pattern with **/*.js.
		const recursivePatterns = subpaths
			.filter(subpath =&#x3e; multimatch(subpath, initialPatterns).length === 1)
			// Always use `/` to makes multimatch consistent across platforms
			.map(subpath =&#x3e; `${subpath}/**/*.js`);

		// See if the entire path matches any of the subpaths patterns, taking the
		// excludePatterns into account. This mimicks the behavior in api.js
		return multimatch(matchable(filePath), recursivePatterns.concat(excludePattern ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ava.ava_files.defaultExcludePatterns" id="apidoc.element.ava.ava_files.defaultExcludePatterns">
        function <span class="apidocSignatureSpan">ava.ava_files.</span>defaultExcludePatterns
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">() =&#x3e; [
	&#x27;!**/node_modules/**&#x27;,
	&#x27;!**/fixtures/**&#x27;,
	&#x27;!**/helpers/**&#x27;
]</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ava.ava_files.defaultIncludePatterns" id="apidoc.element.ava.ava_files.defaultIncludePatterns">
        function <span class="apidocSignatureSpan">ava.ava_files.</span>defaultIncludePatterns
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">() =&#x3e; [
	&#x27;test.js&#x27;,
	&#x27;test-*.js&#x27;,
	&#x27;test&#x27;,
	&#x27;**/__tests__&#x27;,
	&#x27;**/*.test.js&#x27;
]</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ava.babel_config" id="apidoc.module.ava.babel_config">module ava.babel_config</a></h1>


    <h2>
        <a href="#apidoc.element.ava.babel_config.build" id="apidoc.element.ava.babel_config.build">
        function <span class="apidocSignatureSpan">ava.babel_config.</span>build
        <span class="apidocSignatureSpan">(projectDir, cacheDir, userOptions, powerAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function build(projectDir, cacheDir, userOptions, powerAssert) {
	// Compute a seed based on the Node.js version and the project directory.
	// Dependency hashes may vary based on the Node.js version, e.g. with the
	// @ava/stage-4 Babel preset. Sources and dependencies paths are absolute in
	// the generated module and verifier state. Those paths wouldn&#x27;t necessarily
	// be valid if the project directory changes.
	const seed = md5Hex([process.versions.node, projectDir]);

	// Ensure cacheDir exists
	mkdirp.sync(cacheDir);

	// The file names predict where valid options may be cached, and thus should
	// include the seed.
	const optionsFile = path.join(cacheDir, `${seed}.babel-options.js`);
	const verifierFile = path.join(cacheDir, `${seed}.verifier.bin`);

	const baseOptions = {
		babelrc: false,
		presets: [
			[&#x27;@ava/transform-test-files&#x27;, {powerAssert}]
		]
	};
	if (userOptions === &#x27;default&#x27;) {
		baseOptions.presets.unshift(&#x27;@ava/stage-4&#x27;);
	}

	const baseConfig = configManager.createConfig({
		dir: AVA_DIR, // Presets are resolved relative to this directory
		hash: md5Hex(JSON.stringify(baseOptions)),
		json5: false,
		options: baseOptions,
		source: SOURCE
	});

	if (userOptions !== &#x27;default&#x27;) {
		baseConfig.extend(configManager.createConfig({
			dir: projectDir,
			options: userOptions === &#x27;inherit&#x27; ?
				{babelrc: true} :
				userOptions,
			source: path.join(projectDir, &#x27;package.json&#x27;) + &#x27;#ava.babel&#x27;,
			hash: md5Hex(JSON.stringify(userOptions))
		}));
	}

	const cache = configManager.prepareCache();
	return verifyExistingOptions(verifierFile, baseConfig, cache)
		.then(cacheKeys =&#x3e; {
			if (cacheKeys) {
				return cacheKeys;
			}

			return resolveOptions(baseConfig, cache, optionsFile, verifierFile);
		})
		.then(cacheKeys =&#x3e; ({
			getOptions: require(optionsFile).getOptions, // eslint-disable-line import/no-dynamic-require
			// Include the seed in the cache keys used to store compilation results.
			cacheKeys: Object.assign({seed}, cacheKeys)
		}));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
				cacheDir = foundDir;
			}
		}

		this.options.cacheDir = cacheDir;

		const isPowerAssertEnabled = this.options.powerAssert !== false;
		return babelConfigHelper.<span class="apidocCodeKeywordSpan">build</span>(this.options.projectDir, cacheDir, this.options.babelConfig
, isPowerAssertEnabled)
			.then(result =&#x3e; {
				this.precompiler = new CachingPrecompiler({
					path: cacheDir,
					getBabelOptions: result.getOptions,
					babelCacheKeys: result.cacheKeys
				});
			});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ava.babel_config.validate" id="apidoc.element.ava.babel_config.validate">
        function <span class="apidocSignatureSpan">ava.babel_config.</span>validate
        <span class="apidocSignatureSpan">(conf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function validate(conf) {
	if (conf === undefined || conf === null) {
		conf = &#x27;default&#x27;;
	}

	// Check for valid babel config shortcuts (can be either `default` or `inherit`)
	const isValidShortcut = conf === &#x27;default&#x27; || conf === &#x27;inherit&#x27;;

	if (!conf || (typeof conf === &#x27;string&#x27; &#x26;&#x26; !isValidShortcut)) {
		let message = colors.error(figures.cross);
		message += &#x27; Unexpected Babel configuration for AVA. &#x27;;
		message += &#x27;See &#x27; + chalk.underline(&#x27;https://github.com/avajs/ava#es2015-support&#x27;) + &#x27; for allowed values.&#x27;;

		throw new Error(message);
	}

	return conf;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ava.colors" id="apidoc.module.ava.colors">module ava.colors</a></h1>


    <h2>
        <a href="#apidoc.element.ava.colors.duration" id="apidoc.element.ava.colors.duration">
        function <span class="apidocSignatureSpan">ava.colors.</span>duration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">duration = function () {
		return applyStyle.apply(builder, arguments);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

		if (runStatus.fileCount === 1 &#x26;&#x26; runStatus.testCount === 1 &#x26;&#x26; test.title === &#x27;[anonymous]&#x27;) {
			return undefined;
		}

		// Display duration only over a threshold
		const threshold = 100;
		const duration = test.duration &#x3e; threshold ? colors.<span class="apidocCodeKeywordSpan">duration</span>(&#x27; (&#x27; +
prettyMs(test.duration) + &#x27;)&#x27;) : &#x27;&#x27;;

		return &#x27;  &#x27; + colors.pass(figures.tick) + &#x27; &#x27; + test.title + duration;
	}
	unhandledError(err) {
		if (err.type === &#x27;exception&#x27; &#x26;&#x26; err.name === &#x27;AvaError&#x27;) {
			return colors.error(&#x27;  &#x27; + figures.cross + &#x27; &#x27; + err.message);
		}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ava.colors.error" id="apidoc.element.ava.colors.error">
        function <span class="apidocSignatureSpan">ava.colors.</span>error
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error = function () {
		return applyStyle.apply(builder, arguments);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	if (debug.enabled) {
		require(&#x27;time-require&#x27;); // eslint-disable-line import/no-unassigned-import
	}

	try {
		require(&#x27;./lib/cli&#x27;).run();
	} catch (err) {
		console.<span class="apidocCodeKeywordSpan">error</span>(`\n  ${err.message}`);
		process.exit(1);
	}
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ava.colors.errorSource" id="apidoc.element.ava.colors.errorSource">
        function <span class="apidocSignatureSpan">ava.colors.</span>errorSource
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">errorSource = function () {
		return applyStyle.apply(builder, arguments);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
					return;
				}

				const beforeSpacing = index === 0 ? &#x27;\n\n&#x27; : &#x27;\n\n\n\n&#x27;;

				status += beforeSpacing + &#x27;  &#x27; + colors.title(test.title) + &#x27;\n&#x27;;
				if (test.error.source) {
					status += &#x27;  &#x27; + colors.<span class="apidocCodeKeywordSpan">errorSource</span>(test.error.source.file + &#x27;:&#
x27; + test.error.source.line) + &#x27;\n&#x27;;

					const excerpt = codeExcerpt(test.error.source, {maxWidth: process.stdout.columns});
					if (excerpt) {
						status += &#x27;\n&#x27; + indentString(excerpt, 2) + &#x27;\n&#x27;;
					}
				}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ava.colors.errorStack" id="apidoc.element.ava.colors.errorStack">
        function <span class="apidocSignatureSpan">ava.colors.</span>errorStack
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">errorStack = function () {
		return applyStyle.apply(builder, arguments);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
						status += &#x27;\n&#x27; + indentString(message, 2) + &#x27;\n&#x27;;
					}
				}

				if (test.error.stack) {
					const extracted = extractStack(test.error.stack);
					if (extracted.includes(&#x27;\n&#x27;)) {
						status += &#x27;\n&#x27; + indentString(colors.<span class="apidocCodeKeywordSpan">errorStack</span>(extracted), 2);
					}
				}
			});
		}

		if (this.rejectionCount &#x3e; 0 || this.exceptionCount &#x3e; 0) {
			// TODO(sindresorhus): Figure out why this causes a test failure when switched to a for-of loop
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ava.colors.information" id="apidoc.element.ava.colors.information">
        function <span class="apidocSignatureSpan">ava.colors.</span>information
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">information = function () {
		return applyStyle.apply(builder, arguments);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
					status += colors.errorStack(errorStack);
				}
			});
		}

		if (runStatus.failFastEnabled === true &#x26;&#x26; runStatus.remainingCount &#x3e; 0 &#x26;&#x26; runStatus.failCount &#x3e;
0) {
			const remaining = &#x27;At least &#x27; + runStatus.remainingCount + &#x27; &#x27; + plur(&#x27;test was&#x27;, &#x27;tests were
&#x27;, runStatus.remainingCount) + &#x27; skipped.&#x27;;
			status += &#x27;\n\n  &#x27; + colors.<span class="apidocCodeKeywordSpan">information</span>(&#x27;`--fail-fast` is on. &#x27
; + remaining);
		}

		if (runStatus.hasExclusive === true &#x26;&#x26; runStatus.remainingCount &#x3e; 0) {
			status += &#x27;\n\n  &#x27; + colors.information(&#x27;The .only() modifier is used in some tests.&#x27;, runStatus.remainingCount
, plur(&#x27;test&#x27;, runStatus.remainingCount), plur(&#x27;was&#x27;, &#x27;were&#x27;, runStatus.remainingCount), &#x27;not
 run&#x27;);
		}

		return status + &#x27;\n\n&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ava.colors.pass" id="apidoc.element.ava.colors.pass">
        function <span class="apidocSignatureSpan">ava.colors.</span>pass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pass = function () {
		return applyStyle.apply(builder, arguments);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Create a file named `test.js` in the project root directory:

```js
import test from &#x27;ava&#x27;;

test(&#x27;foo&#x27;, t =&#x3e; {
	t.<span class="apidocCodeKeywordSpan">pass</span>();
});

test(&#x27;bar&#x27;, async t =&#x3e; {
	const bar = Promise.resolve(&#x27;bar&#x27;);

	t.is(await bar, &#x27;bar&#x27;);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ava.colors.skip" id="apidoc.element.ava.colors.skip">
        function <span class="apidocSignatureSpan">ava.colors.</span>skip
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skip = function () {
		return applyStyle.apply(builder, arguments);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

### Skipping tests

Sometimes failing tests can be hard to fix. You can tell AVA to skip these tests using the `.skip` modifier. They&#x27;ll still
be shown in the output (as having been skipped) but are never run.

```js
test.<span class="apidocCodeKeywordSpan">skip</span>(&#x27;will not be run&#x27;, t =&#x3e; {
	t.fail();
});
```

You must specify the implementation function.

### Test placeholders (&#x22;todo&#x22;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ava.colors.stack" id="apidoc.element.ava.colors.stack">
        function <span class="apidocSignatureSpan">ava.colors.</span>stack
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stack = function () {
		return applyStyle.apply(builder, arguments);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		}

		if (this.knownFailureCount &#x3e; 0) {
			for (const test of runStatus.knownFailures) {
				const title = test.title;
				status += &#x27;\n\n   &#x27; + colors.title(title);
				// TODO: Output description with link
				// status += colors.<span class="apidocCodeKeywordSpan">stack</span>(description);
			}
		}

		if (this.failCount &#x3e; 0) {
			runStatus.errors.forEach((test, index) =&#x3e; {
				if (!test.error) {
					return;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ava.colors.title" id="apidoc.element.ava.colors.title">
        function <span class="apidocSignatureSpan">ava.colors.</span>title
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">title = function () {
		return applyStyle.apply(builder, arguments);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		if (runStatus.previousFailCount &#x3e; 0) {
			status += &#x27;\n  &#x27; + colors.error(runStatus.previousFailCount, &#x27;previous&#x27;, plur(&#x27;failure&#x27;, runStatus
.previousFailCount), &#x27;in test files that were not rerun&#x27;);
		}

		if (this.knownFailureCount &#x3e; 0) {
			for (const test of runStatus.knownFailures) {
				const title = test.title;
				status += &#x27;\n\n   &#x27; + colors.<span class="apidocCodeKeywordSpan">title</span>(title);
				// TODO: Output description with link
				// status += colors.stack(description);
			}
		}

		if (this.failCount &#x3e; 0) {
			runStatus.errors.forEach((test, index) =&#x3e; {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ava.colors.todo" id="apidoc.element.ava.colors.todo">
        function <span class="apidocSignatureSpan">ava.colors.</span>todo
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">todo = function () {
		return applyStyle.apply(builder, arguments);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
You must specify the implementation function.

### Test placeholders (&#x22;todo&#x22;)

You can use the `.todo` modifier when you&#x27;re planning to write a test. Like skipped tests these placeholders are shown in the
 output. They only require a title; you cannot specify the implementation function.

```js
test.<span class="apidocCodeKeywordSpan">todo</span>(&#x27;will think about writing this later&#x27;);
```

### Failing tests

You can use the `.failing` modifier to document issues with your code that need to be fixed. Failing tests are run just like normal
 ones, but they are expected to fail, and will not break your build when they do. If a test marked as failing actually passes, it
 will be reported as an error and fail the build with a helpful message instructing you to remove the `.failing` modifier.

This allows you to merge `.failing` tests before a fix is implemented without breaking CI. This is a great way to recognize good
 bug report PR&#x27;s with a commit credit, even if the reporter is unable to actually fix the problem.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ava.format_assert_error" id="apidoc.module.ava.format_assert_error">module ava.format_assert_error</a></h1>


    <h2>
        <a href="#apidoc.element.ava.format_assert_error.formatDiff" id="apidoc.element.ava.format_assert_error.formatDiff">
        function <span class="apidocSignatureSpan">ava.format_assert_error.</span>formatDiff
        <span class="apidocSignatureSpan">(actual, expected)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function formatDiff(actual, expected) {
	const actualType = getType(actual);
	const expectedType = getType(expected);
	if (actualType !== expectedType) {
		return null;
	}

	if (actualType === &#x27;array&#x27; || actualType === &#x27;object&#x27;) {
		const formatted = diff.createPatch(&#x27;string&#x27;, formatValue(actual), formatValue(expected))
			.split(&#x27;\n&#x27;)
			.slice(4)
			.map(cleanUp)
			.filter(Boolean)
			.join(&#x27;\n&#x27;)
			.trimRight();

		return {label: &#x27;Difference:&#x27;, formatted};
	}

	if (actualType === &#x27;string&#x27;) {
		const formatted = new DiffMatchPatch()
			.diff_main(formatValue(actual, {highlight: false}), formatValue(expected, {highlight: false}))
			.map(part =&#x3e; {
				if (part[0] === 1) {
					return chalk.bgGreen.black(part[1]);
				}

				if (part[0] === -1) {
					return chalk.bgRed.black(part[1]);
				}

				return chalk.red(part[1]);
			})
			.join(&#x27;&#x27;)
			.trimRight();

		return {label: &#x27;Difference:&#x27;, formatted};
	}

	return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			}));
		},

		is(actual, expected, message) {
			if (actual === expected) {
				pass(this);
			} else {
				const diff = formatAssertError.<span class="apidocCodeKeywordSpan">formatDiff</span>(actual, expected);
				const values = diff ? [diff] : [
					formatAssertError.formatWithLabel(&#x27;Actual:&#x27;, actual),
					formatAssertError.formatWithLabel(&#x27;Must be strictly equal to:&#x27;, expected)
				];

				fail(this, new AssertionError({
					assertion: &#x27;is&#x27;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ava.format_assert_error.formatSerializedError" id="apidoc.element.ava.format_assert_error.formatSerializedError">
        function <span class="apidocSignatureSpan">ava.format_assert_error.</span>formatSerializedError
        <span class="apidocSignatureSpan">(error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function formatSerializedError(error) {
	if (error.statements.length === 0 &#x26;&#x26; error.values.length === 0) {
		return null;
	}

	let result = error.values
		.map(value =&#x3e; `${value.label}\n\n${indentString(value.formatted, 2).trimRight()}\n`)
		.join(&#x27;\n&#x27;);

	if (error.statements.length &#x3e; 0) {
		if (error.values.length &#x3e; 0) {
			result += &#x27;\n&#x27;;
		}

		result += error.statements
			.map(statement =&#x3e; `${statement[0]}\n${chalk.grey(&#x27;=&#x3e;&#x27;)} ${statement[1]}\n`)
			.join(&#x27;\n&#x27;);
	}

	return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
				}

				if (test.error.message) {
					status += &#x27;\n&#x27; + indentString(test.error.message, 2) + &#x27;\n&#x27;;
				}

				if (test.error.avaAssertionError) {
					const formatted = formatAssertError.<span class="apidocCodeKeywordSpan">formatSerializedError</span>(test.error);
					if (formatted) {
						status += &#x27;\n&#x27; + indentString(formatted, 2);
					}

					const message = improperUsageMessages.forError(test.error);
					if (message) {
						status += &#x27;\n&#x27; + indentString(message, 2) + &#x27;\n&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ava.format_assert_error.formatValue" id="apidoc.element.ava.format_assert_error.formatValue">
        function <span class="apidocSignatureSpan">ava.format_assert_error.</span>formatValue
        <span class="apidocSignatureSpan">(value, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function formatValue(value, options) {
	return prettyFormat(value, Object.assign({
		callToJSON: false,
		plugins: [reactTestPlugin],
		highlight: globals.options.color !== false
	}, options));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ava.format_assert_error.formatWithLabel" id="apidoc.element.ava.format_assert_error.formatWithLabel">
        function <span class="apidocSignatureSpan">ava.format_assert_error.</span>formatWithLabel
        <span class="apidocSignatureSpan">(label, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function formatWithLabel(label, value) {
	return {label, formatted: formatValue(value)};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

		is(actual, expected, message) {
			if (actual === expected) {
				pass(this);
			} else {
				const diff = formatAssertError.formatDiff(actual, expected);
				const values = diff ? [diff] : [
					formatAssertError.<span class="apidocCodeKeywordSpan">formatWithLabel</span>(&#x27;Actual:&#x27;, actual),
					formatAssertError.formatWithLabel(&#x27;Must be strictly equal to:&#x27;, expected)
				];

				fail(this, new AssertionError({
					assertion: &#x27;is&#x27;,
					message,
					operator: &#x27;===&#x27;,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ava.globals" id="apidoc.module.ava.globals">module ava.globals</a></h1>


    <h2>
        <a href="#apidoc.element.ava.globals.clearTimeout" id="apidoc.element.ava.globals.clearTimeout">
        function <span class="apidocSignatureSpan">ava.globals.</span>clearTimeout
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearTimeout = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ava.globals.now" id="apidoc.element.ava.globals.now">
        function <span class="apidocSignatureSpan">ava.globals.</span>now
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function now() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ava.globals.setImmediate" id="apidoc.element.ava.globals.setImmediate">
        function <span class="apidocSignatureSpan">ava.globals.</span>setImmediate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setImmediate = function () {
<span class="apidocCodeCommentSpan">/*
 * this function will do nothing
 */
</span>    return;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ava.globals.setTimeout" id="apidoc.element.ava.globals.setTimeout">
        function <span class="apidocSignatureSpan">ava.globals.</span>setTimeout
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setTimeout = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ava.improper_usage_messages" id="apidoc.module.ava.improper_usage_messages">module ava.improper_usage_messages</a></h1>


    <h2>
        <a href="#apidoc.element.ava.improper_usage_messages.forError" id="apidoc.element.ava.improper_usage_messages.forError">
        function <span class="apidocSignatureSpan">ava.improper_usage_messages.</span>forError
        <span class="apidocSignatureSpan">(!error.improperUsage)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error =&#x3e; {
	if (!error.improperUsage) {
		return null;
	}

	const assertion = error.assertion;
	if (assertion !== &#x27;throws&#x27; || !assertion === &#x27;notThrows&#x27;) {
		return null;
	}

	return `Try wrapping the first argument to \`t.${assertion}()\` in a function:

  ${chalk.cyan(`t.${assertion}(() =&#x3e; { `)}${chalk.grey(&#x27;/* your code here */&#x27;)}${chalk.cyan(&#x27; })&#x27;)}

Visit the following URL for more details:

  ${chalk.blue.underline(&#x27;https://github.com/avajs/ava#throwsfunctionpromise-error-message&#x27;)}`;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

				if (test.error.avaAssertionError) {
					const formatted = formatAssertError.formatSerializedError(test.error);
					if (formatted) {
						status += &#x27;\n&#x27; + indentString(formatted, 2);
					}

					const message = improperUsageMessages.<span class="apidocCodeKeywordSpan">forError</span>(test.error);
					if (message) {
						status += &#x27;\n&#x27; + indentString(message, 2) + &#x27;\n&#x27;;
					}
				}

				if (test.error.stack) {
					const extracted = extractStack(test.error.stack);
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
